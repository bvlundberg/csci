;Lab 3

;butSecondLast (element)
;(define (butSecondLast as)
;
;)
(define ls (list 1 2 3 4))
(define lt (list 1 2 (list 3 ) ) )
(define lr (list 1 2 (list 3 4 (list 5) ) ) )
(define ld (list 1 2 3 (list (list 4 5))))


;(define butLast
;	(lambda (l)
;		(if (null? (cdr l))
;		'()
;		(cons (car l) (butLast (cdr l)) )
;        )
;	)
;)
(define (butSecondLast as)
	(if (null? (cddr as))
		(cdr as)
		(cons (car as) (butSecondLast (cdr as)) )
    )
)
(define isAtom
	(lambda (x)
		(and (not (null? x)) (not (pair? x)))
	)
)
;
;(define flatten
;	(lambda (l)
;		(if (null? (cdr l))
;			(if (isAtom (car l))
;				l
;				( flatten (car l) )
;			)
;		(cons (car l) (flatten (cdr l)) )
 ;       )
;	)
;)
;
(define (butLastAtom l)
		(if (null? (cdr l))
				(if (isAtom (car l))
					'()
					( cons( butLastAtom (car l)) '())
				)
			(cons (car l) (butLastAtom (cdr l)) )
       	)
)

(define (atom? a)
	(cond
		((and (not(pair? a)) (not(null? a))) #t)
		(else #f)
	)
)
; Good State!
(define (butSecondLastAtom as)
		(if (not (null? (cdr as))) 
				(if(nextNull (cdr as))
					(cdr as)
					(cons (car as) (butSecondLastAtom (cdr as)) )
				)
			(cons (car as) (butSecondLastAtom (cdr as)))
		)
)
(define (nextNull as)
	(null? (cdr as))
)
;(define ls (list 1 2 3 4))
;(define lt (list 1 2 (list 3 ) ) )
;(define lr (list 1 2 (list 3 4 (list 5) ) ) )
;(define ld (list 1 2 3 (list (list 4 5))))

(define (nestingDepth as)
	(cond 
		((null?  as) 0)
		((not(atom?  (car as))) (+ 1 (nestingDepth (cdr as))))
		(else (+ 0 (nestingDepth (cdr as))))
	)
)

;> (butLast ls)
;(1 2 3)
;> (butLast lt)
;(1 2)
;> (butLast lr)
;(1 2)
;> (butLast ld)
;(1 2 3)


;> (butLastAtom ls)
;(1 2 3)
;> (butLastAtom lt)
;(1 2 ())
;> (butLastAtom lr)
;(1 2 (3 4 ()))
;> (butLastAtom ld)
;(1 2 3 ((4)))
